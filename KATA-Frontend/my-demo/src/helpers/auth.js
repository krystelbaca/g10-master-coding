import { useState, useEffect, useContext, createContext } from 'react';

const authContext = createContext();

export const useAuth = () => {
    return useContext(authContext);
  };

/*
Store the calculated signature here, so we can verify it later.
*/
let signature;

/*
Encryption key generated by the Crypto
*/
let encryptionKey;

/*
Fetch the contents of the "message" textbox, and encode it
in a form we can use for sign operation.
*/
function getMessageEncoding(message) {
    let enc = new TextEncoder();
    return enc.encode(message);
}

/*
Get the encoded message-to-sign, sign it and display a representation
of the first part of it in the "signature" element.
*/
async function signMessage(message) {

    let encoded = getMessageEncoding(message);
    signature = await window.crypto.subtle.sign(
        "HMAC",
        encryptionKey,
        encoded
    );
}

/*
Fetch the encoded message-to-sign and verify it against the stored signature.
* If it checks out, set the "valid" class on the signature.
* Otherwise set the "invalid" class.
*/
async function verifyMessage(message) {
    let encoded = getMessageEncoding(message);
    let result = await window.crypto.subtle.verify(
        "HMAC",
        encryptionKey,
        signature,
        encoded
    );

    if(result) {
        console.log('Valid credentials');
    } else {
        console.log('Invalid credentials');
    }
}

/*
Generate a sign/verify key, then set up event listeners
on the "Sign" and "Verify" buttons.
*/
window.crypto.subtle.generateKey(
        {
            name: "HMAC",
            hash: {name: "SHA-256"}
        },
        true,
        ["sign", "verify"]
    ).then((key) => {
        encryptionKey = key;
});

// Provider component that wraps your app and makes auth object ...
// ... available to any child component that calls useAuth().
export function ProvideAuth({ children }) {
    const auth = useProvideAuth();
    return <authContext.Provider value={auth}>{children}</authContext.Provider>;
}

// Provider hook that creates auth object and handles state
function useProvideAuth() {
    const [user, setUser] = useState(null);
    // ... to save the user to state.
    const login = (email, password) => {
        setUser(true);
    };

    const logout = () => {
        setUser(false);
    };
    
    // Subscribe to user on mount
    // Because this sets state in the callback it will cause any ...
    // ... component that utilizes this hook to re-render with the ...
    // ... latest auth object.
    useEffect(() => {
      // Apply effect
    }, [user]);
    // Return the user object and auth methods
    return {
      user,
      login,
      logout,
      verifyMessage,
      signMessage,
    };
  }